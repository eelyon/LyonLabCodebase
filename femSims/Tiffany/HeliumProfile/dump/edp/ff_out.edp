
//////////////////////////////////////////////////////////
//
//    HELIUM CURVATURE
//
//////////////////////////////////////////////////////////

load "gmsh"
mesh heliumsurfTh = gmshload("dump\\geo\\heliumsurface.msh");
cout << "Area: " << int2d(heliumsurfTh)(1.0) << endl;

fespace heliumsurfVh(heliumsurfTh,P2);
heliumsurfVh<real> disp,vdisp;
problem HeliumSurfaceCalculate(disp,vdisp,solver=CG) =
    int2d(heliumsurfTh)( (dx(disp)*dx(vdisp) + dy(disp)*dy(vdisp)) )
    - int2d(heliumsurfTh)( 1*vdisp )
    + on (2,disp=0);

HeliumSurfaceCalculate;
heliumsurfTh = adaptmesh( heliumsurfTh, disp, hmax = .5, hmin = 0.02, iso = 1, nbvx = 10000 );
HeliumSurfaceCalculate;
cout << "Helium Surface Calculations are finished" << endl;

//////////////////////////////////////////////////////////
//
//    HELIUM CURVATURE
//
//////////////////////////////////////////////////////////


ofstream result1("dump\\edp\\result1_out.npy", binary);
ofstream result2("dump\\edp\\result2_out.npy", binary);
ofstream result3("dump\\edp\\result3_out.npy", binary);
load "msh3"
load "gmsh"
load "medit"
load "mshmet"
load "tetgen"

mesh3 Th = gmshload3("dump\\geo\\dot.msh");

int n1, n2, n3;
real xmin, xmax, ymin, ymax, ax3;

int numV = 3;

real[int] electrodeid = [5, 6, 7];

fespace Vh(Th,P23d);
fespace FunctionRegion(Th,P03d);
real eps = 1e-6;
macro norm [N.x,N.y,N.z] //
macro Grad(u) [dx(u),dy(u),dz(u)] //
macro field(u,x,y,z) [dx(u)(x,y,z),dy(u)(x,y,z),dz(u)(x,y,z)] //
 
Vh u,v;
FunctionRegion dielectric =
                          + 1.0 * (region == 1)
                          + 1.0 * (region == 2)
                          + 1.057 * (region == 3)
                          + 11.0 * (region == 4)
                          ;
problem Electro(u,v,solver=CG) =
                int3d(Th)(dielectric * Grad(u)' * Grad(v))
                + on(6,u = 1.0)
                + on(5,u = 0.0)
                + on(7,u = 0.0)
                ;
Electro;

//////////////////////////////////////////////////////////
//
//    START / Calculate Capacitance Matrix
//
//////////////////////////////////////////////////////////

ofstream cmextract("dump\\edp\\cm_out.txt");

for(int i = 0; i < numV; i++){
    real charge = int2d(Th,electrodeid[i])((dielectric(x + eps*N.x, y + eps*N.y, z + eps*N.z) * field(u, x + eps*N.x, y + eps*N.y, z + eps*N.z)' * norm
                                          - dielectric(x - eps*N.x, y - eps*N.y, z - eps*N.z) * field(u, x - eps*N.x, y - eps*N.y, z - eps*N.z)' * norm));
    cmextract << charge << endl;
}

//////////////////////////////////////////////////////////
//
//    END / Calculate Capacitance Matrix
//
//////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////
//
//    2D SLICES DATA EXTRACTION BLOCK START
//
//////////////////////////////////////////////////////////

{
n1 = 201;
n2 = 201;
xmin = -10;
xmax = 10;
ymin = -10;
ymax = 10;
n3 = 1;
real[int] zcoords = [1.6];
for(int m = 0; m < n3; m++){
    real ax3 = zcoords[m];
    for(int j = 0; j < n2; j++){
        real ax2 = ymin + j*(ymax-ymin)/(n2-1);
        for(int i = 0; i < n1; i++){
            real ax1 = xmin + i*(xmax-xmin)/(n1-1);
            result1 << u(ax1,ax2,ax3) << endl;
            }
        }
    }
}

//////////////////////////////////////////////////////////
//
//    2D SLICES DATA EXTRACTION BLOCK END
//
//////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////
//
//    2D SLICES DATA EXTRACTION BLOCK START
//
//////////////////////////////////////////////////////////

{
n1 = 201;
n2 = 201;
xmin = -10;
xmax = 10;
ymin = -10;
ymax = 10;
n3 = 4;
real[int] bulkHeliumLevels = [0.   , 0.001, 0.01 , 0.02 ];
real[int] bulkHeliumLevelDispScales = [0.        , 0.00400073, 0.04000726, 0.08001453];
for(int m = 0; m < n3; m++){
    for(int j = 0; j < n2; j++){
        real ax2 = ymin + j*(ymax-ymin)/(n2-1);
        for(int i = 0; i < n1; i++){
            real ax1 = xmin + i*(xmax-xmin)/(n1-1);
            real ax3 = 1.6 - bulkHeliumLevelDispScales[m] * disp(ax1,ax2);
            result2 << u(ax1,ax2,ax3) << endl;
            }
        }
    }
}

//////////////////////////////////////////////////////////
//
//    2D SLICES DATA EXTRACTION BLOCK END
//
//////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////
//
//    2D SLICES DATA EXTRACTION BLOCK START
//
//////////////////////////////////////////////////////////

{
n1 = 101;
n2 = 101;
xmin = -10;
xmax = 10;
ymin = -2;
ymax = 2;
n3 = 1;
real[int] zcoords = [0.0];
for(int m = 0; m < n3; m++){
    real ax3 = zcoords[m];
    for(int j = 0; j < n2; j++){
        real ax2 = ymin + j*(ymax-ymin)/(n2-1);
        for(int i = 0; i < n1; i++){
            real ax1 = xmin + i*(xmax-xmin)/(n1-1);
            result3 << dz(u)(ax3,ax1,ax2) << endl;
            }
        }
    }
}

//////////////////////////////////////////////////////////
//
//    2D SLICES DATA EXTRACTION BLOCK END
//
//////////////////////////////////////////////////////////

